<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>å‚»ç“œåŠ‡åœ˜éŸ³æ•ˆç®¡ç†ç³»çµ±</title>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script crossorigin src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone@7.23.5/babel.min.js"></script>
<script src="https://cdn.tailwindcss.com"></script>
<script type="module">
  import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
  import { getFirestore, collection, getDocs, doc, setDoc, deleteDoc, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js';
  import { getStorage, ref, uploadBytesResumable, getDownloadURL, deleteObject } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';

  const firebaseConfig = {
    apiKey: "AIzaSyCWB3RtXPejX8WMMu65F_woVffotLiyCPE",
    authDomain: "nccutheater-ab03c.firebaseapp.com",
    projectId: "nccutheater-ab03c",
    storageBucket: "nccutheater-ab03c.firebasestorage.app",
    messagingSenderId: "194078255051",
    appId: "1:194078255051:web:92b65aa4515985711df84e"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  const storage = getStorage(app);
  
  window.firebaseDB = db;
  window.firebaseStorage = storage;
  window.firebaseUtils = { collection, getDocs, doc, setDoc, deleteDoc, getDoc, ref, uploadBytesResumable, getDownloadURL, deleteObject };
  window.firebaseReady = true;
</script>
<style>
  body { margin: 0; padding: 0; }
  #root { min-height: 100vh; }
  input[type="range"] {
    -webkit-appearance: none;
    appearance: none;
    height: 8px;
    border-radius: 4px;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #3b82f6;
    cursor: pointer;
  }
  input[type="range"]::-moz-range-thumb {
    width: 16px;
    height: 16px;
    border-radius: 50%;
    background: #3b82f6;
    cursor: pointer;
    border: none;
  }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useRef, useEffect } = React;

const DB_NAME = 'TheaterAppDB';
const STORE_NAME = 'projects';
const MEDIA_STORE_NAME = 'mediaLibrary';

const initDB = () => {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 2);
    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);
    request.onupgradeneeded = (e) => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
      }
      if (!db.objectStoreNames.contains(MEDIA_STORE_NAME)) {
        db.createObjectStore(MEDIA_STORE_NAME, { keyPath: 'id' });
      }
    };
  });
};

const saveProjectsToDB = async (projects) => {
  const db = await initDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);
    store.clear();
    projects.forEach(p => store.add(p));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
};

const loadProjectsFromDB = async () => {
  const db = await initDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

const saveMediaToDB = async (mediaItems) => {
  const db = await initDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(MEDIA_STORE_NAME, 'readwrite');
    const store = tx.objectStore(MEDIA_STORE_NAME);
    store.clear();
    mediaItems.forEach(m => store.add(m));
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
};

const loadMediaFromDB = async () => {
  const db = await initDB();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(MEDIA_STORE_NAME, 'readonly');
    const store = tx.objectStore(MEDIA_STORE_NAME);
    const request = store.getAll();
    request.onsuccess = () => resolve(request.result);
    request.onerror = () => reject(request.error);
  });
};

const dataURLtoBlob = (dataURL) => {
  const arr = dataURL.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr = atob(arr[1]);
  let n = bstr.length;
  const u8arr = new Uint8Array(n);
  while (n--) {
    u8arr[n] = bstr.charCodeAt(n);
  }
  return new Blob([u8arr], { type: mime });
};

function TheaterApp() {
  const [projects, setProjects] = useState([]);
  const [mediaLibrary, setMediaLibrary] = useState([]);
  const [currentProjectId, setCurrentProjectId] = useState(null);
  const [currentPage, setCurrentPage] = useState('projects');
  const [newProjectName, setNewProjectName] = useState('');
  const [newChapterName, setNewChapterName] = useState('');
  const [newSectionName, setNewSectionName] = useState('');
  const [newChapterId, setNewChapterId] = useState(null);
  const [currentPlayingId, setCurrentPlayingId] = useState(null);
  const [isPaused, setIsPaused] = useState(false);
  const [volume, setVolume] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [currentTime, setCurrentTime] = useState(0);
  const [duration, setDuration] = useState(0);
  const [editingProjectId, setEditingProjectId] = useState(null);
  const [editingProjectName, setEditingProjectName] = useState('');
  const [editingChapterId, setEditingChapterId] = useState(null);
  const [editingChapterName, setEditingChapterName] = useState('');
  const [editingSectionId, setEditingSectionId] = useState(null);
  const [editingSectionName, setEditingSectionName] = useState('');
  const [isSyncing, setIsSyncing] = useState(false);
  const [showMediaSelector, setShowMediaSelector] = useState(false);
  const [selectingForSection, setSelectingForSection] = useState(null);
  const [uploadProgress, setUploadProgress] = useState({});
  const [syncStatus, setSyncStatus] = useState('');
  const audioRef = useRef(null);

  const waitForFirebase = () => {
    return new Promise((resolve) => {
      const check = () => {
        if (window.firebaseReady && window.firebaseDB && window.firebaseStorage) {
          resolve();
        } else {
          setTimeout(check, 100);
        }
      };
      check();
    });
  };

  const uploadMediaToStorage = async (mediaId, file, onProgress) => {
    await waitForFirebase();
    const { ref, uploadBytesResumable, getDownloadURL } = window.firebaseUtils;
    
    const storageRef = ref(window.firebaseStorage, `media/${mediaId}_${file.name}`);
    const blob = dataURLtoBlob(file.audioData);
    
    return new Promise((resolve, reject) => {
      const uploadTask = uploadBytesResumable(storageRef, blob);
      
      uploadTask.on('state_changed',
        (snapshot) => {
          const progress = (snapshot.bytesTransferred / snapshot.totalBytes) * 100;
          if (onProgress) onProgress(progress);
        },
        (error) => {
          console.error('ä¸Šå‚³å¤±æ•—:', error);
          reject(error);
        },
        async () => {
          const downloadURL = await getDownloadURL(uploadTask.snapshot.ref);
          resolve(downloadURL);
        }
      );
    });
  };

  const saveMediaMetadataToFirestore = async (media) => {
    await waitForFirebase();
    const { doc, setDoc } = window.firebaseUtils;
    
    try {
      const mediaDoc = {
        id: media.id,
        name: media.name,
        uploadDate: media.uploadDate,
        storageUrl: media.storageUrl,
        storagePath: media.storagePath
      };
      
      const docRef = doc(window.firebaseDB, 'mediaLibrary', media.id.toString());
      await setDoc(docRef, mediaDoc);
    } catch (error) {
      console.error('Firestore å„²å­˜å¤±æ•—:', error);
      throw error;
    }
  };

  const loadMediaMetadataFromFirestore = async () => {
    await waitForFirebase();
    const { collection, getDocs } = window.firebaseUtils;
    
    try {
      const querySnapshot = await getDocs(collection(window.firebaseDB, 'mediaLibrary'));
      const mediaMetadata = [];
      querySnapshot.forEach((doc) => {
        mediaMetadata.push(doc.data());
      });
      return mediaMetadata;
    } catch (error) {
      console.error('Firestore è¼‰å…¥å¤±æ•—:', error);
      return [];
    }
  };

  const downloadMediaFromUrl = async (url) => {
    try {
      const response = await fetch(url);
      const blob = await response.blob();
      return new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(blob);
      });
    } catch (error) {
      console.error('ä¸‹è¼‰éŸ³æª”å¤±æ•—:', error);
      return null;
    }
  };

  const deleteMediaFromStorage = async (storagePath) => {
    await waitForFirebase();
    const { ref, deleteObject } = window.firebaseUtils;
    
    try {
      const storageRef = ref(window.firebaseStorage, storagePath);
      await deleteObject(storageRef);
    } catch (error) {
      console.error('Storage åˆªé™¤å¤±æ•—:', error);
    }
  };

  const deleteMediaMetadataFromFirestore = async (mediaId) => {
    await waitForFirebase();
    const { doc, deleteDoc } = window.firebaseUtils;
    
    try {
      await deleteDoc(doc(window.firebaseDB, 'mediaLibrary', mediaId.toString()));
    } catch (error) {
      console.error('Firestore åˆªé™¤å¤±æ•—:', error);
    }
  };

  const syncMediaLibrary = async () => {
    setSyncStatus('æ­£åœ¨åŒæ­¥åª’é«”åº«...');
    
    try {
      await waitForFirebase();
      
      const cloudMedia = await loadMediaMetadataFromFirestore();
      const localMedia = await loadMediaFromDB();
      
      const cloudIds = new Set(cloudMedia.map(m => m.id));
      const localIds = new Set(localMedia.map(m => m.id));
      
      const toUpload = localMedia.filter(m => !cloudIds.has(m.id) && !m.storageUrl);
      for (const media of toUpload) {
        try {
          setSyncStatus(`ä¸Šå‚³ ${media.name}...`);
          const storagePath = `media/${media.id}_${media.name}`;
          const storageUrl = await uploadMediaToStorage(media.id, media, (progress) => {
            setUploadProgress(prev => ({ ...prev, [media.id]: progress }));
          });
          
          media.storageUrl = storageUrl;
          media.storagePath = storagePath;
          await saveMediaMetadataToFirestore(media);
          
          setUploadProgress(prev => {
            const newProgress = { ...prev };
            delete newProgress[media.id];
            return newProgress;
          });
        } catch (error) {
          console.error(`ä¸Šå‚³ ${media.name} å¤±æ•—:`, error);
        }
      }
      
      const toDownload = cloudMedia.filter(m => !localIds.has(m.id));
      for (const metadata of toDownload) {
        try {
          setSyncStatus(`ä¸‹è¼‰ ${metadata.name}...`);
          const audioData = await downloadMediaFromUrl(metadata.storageUrl);
          if (audioData) {
            localMedia.push({
              ...metadata,
              audioData
            });
          }
        } catch (error) {
          console.error(`ä¸‹è¼‰ ${metadata.name} å¤±æ•—:`, error);
        }
      }
      
      setMediaLibrary(localMedia);
      await saveMediaToDB(localMedia);
      
      setSyncStatus('åŒæ­¥å®Œæˆ!');
      setTimeout(() => setSyncStatus(''), 2000);
      
    } catch (error) {
      console.error('åª’é«”åº«åŒæ­¥å¤±æ•—:', error);
      setSyncStatus('åŒæ­¥å¤±æ•—');
      setTimeout(() => setSyncStatus(''), 2000);
    }
  };

  const saveProjectsToFirebase = async (projects) => {
    if (!window.firebaseDB) return;
    const { doc, setDoc } = window.firebaseUtils;
    
    try {
      for (const project of projects) {
        const projectToSave = {
          ...project,
          chapters: project.chapters.map(chapter => ({
            ...chapter,
            sections: chapter.sections.map(section => ({
              id: section.id,
              name: section.name,
              cue: section.cue,
              audioFile: section.audioFile,
              mediaId: section.mediaId
            }))
          }))
        };
        
        const docRef = doc(window.firebaseDB, 'projects', project.id.toString());
        await setDoc(docRef, projectToSave);
      }
    } catch (error) {
      console.error('Firebase åŒæ­¥å¤±æ•—:', error);
    }
  };

  const loadProjectsFromFirebase = async () => {
    if (!window.firebaseDB) return [];
    const { collection, getDocs } = window.firebaseUtils;
    
    try {
      const querySnapshot = await getDocs(collection(window.firebaseDB, 'projects'));
      const firebaseProjects = [];
      querySnapshot.forEach((doc) => {
        firebaseProjects.push(doc.data());
      });
      return firebaseProjects;
    } catch (error) {
      console.error('Firebase è¼‰å…¥å¤±æ•—:', error);
      return [];
    }
  };

  const deleteProjectFromFirebase = async (projectId) => {
    if (!window.firebaseDB) return;
    const { doc, deleteDoc } = window.firebaseUtils;
    
    try {
      await deleteDoc(doc(window.firebaseDB, 'projects', projectId.toString()));
    } catch (error) {
      console.error('Firebase åˆªé™¤å¤±æ•—:', error);
    }
  };

  useEffect(() => {
    const loadData = async () => {
      try {
        const savedProjects = await loadProjectsFromDB();
        const savedMedia = await loadMediaFromDB();
        setProjects(savedProjects);
        setMediaLibrary(savedMedia);
        
        syncMediaLibrary();
      } catch (error) {
        console.error('è¼‰å…¥è³‡æ–™å¤±æ•—:', error);
      }
      setIsLoading(false);
    };
    loadData();
  }, []);

  useEffect(() => {
    const syncData = async () => {
      if (!isLoading && projects.length >= 0) {
        try {
          await saveProjectsToDB(projects);
        } catch (e) {
          console.log('æœ¬åœ°ä¿å­˜å¤±æ•—:', e.message);
        }
        
        await waitForFirebase();
        
        try {
          await saveProjectsToFirebase(projects);
        } catch (e) {
          console.log('Firebase ä¿å­˜å¤±æ•—:', e.message);
        }
      }
    };
    
    syncData();
  }, [projects, isLoading]);

  useEffect(() => {
    const syncMedia = async () => {
      if (!isLoading) {
        try {
          await saveMediaToDB(mediaLibrary);
        } catch (e) {
          console.log('åª’é«”åº«ä¿å­˜å¤±æ•—:', e.message);
        }
      }
    };
    syncMedia();
  }, [mediaLibrary, isLoading]);

  const currentProject = projects.find(p => p.id === currentProjectId);

  const addProject = () => {
    if (!newProjectName.trim()) return;
    setProjects([...projects, { id: Date.now(), name: newProjectName, chapters: [] }]);
    setNewProjectName('');
  };

  const deleteProject = (id) => {
    const project = projects.find(p => p.id === id);
    if (window.confirm(`ç¢ºå®šè¦åˆªé™¤å°ˆæ¡ˆã€Œ${project.name}ã€å—?\nåˆªé™¤å¾Œå°‡ç„¡æ³•å¾©åŸã€‚`)) {
      setProjects(projects.filter(p => p.id !== id));
      deleteProjectFromFirebase(id);
      if (currentProjectId === id) {
        setCurrentProjectId(null);
        setCurrentPage('projects');
      }
    }
  };

  const duplicateProject = (projectToDuplicate) => {
    const baseName = projectToDuplicate.name;
    let copyNumber = 1;
    let newName = `${baseName} (è¤‡è£½ ${copyNumber})`;
    while (projects.some(p => p.name === newName)) {
      copyNumber++;
      newName = `${baseName} (è¤‡è£½ ${copyNumber})`;
    }
    const newProject = {
      id: Date.now(),
      name: newName,
      chapters: projectToDuplicate.chapters.map(chapter => ({
        ...chapter,
        id: Date.now() + Math.random(),
        sections: chapter.sections.map(section => ({ ...section, id: Date.now() + Math.random() }))
      }))
    };
    setProjects([...projects, newProject]);
  };

  const moveProject = (index, direction) => {
    const newProjects = [...projects];
    const newIndex = direction === 'up' ? index - 1 : index + 1;
    if (newIndex < 0 || newIndex >= newProjects.length) return;
    [newProjects[index], newProjects[newIndex]] = [newProjects[newIndex], newProjects[index]];
    setProjects(newProjects);
  };

  const updateProjectName = (id, newName) => {
    if (!newName.trim()) return;
    setProjects(projects.map(p => p.id === id ? { ...p, name: newName } : p));
    setEditingProjectId(null);
  };

  const updateChapterName = (chapterId, newName) => {
    if (!newName.trim()) return;
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.map(c => 
        c.id === chapterId ? { ...c, name: newName } : c
      )
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
    setEditingChapterId(null);
  };

  const updateSectionName = (chapterId, sectionId, newName) => {
    if (!newName.trim()) return;
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.map(c =>
        c.id === chapterId
          ? {
              ...c,
              sections: c.sections.map(s =>
                s.id === sectionId ? { ...s, name: newName } : s
              )
            }
          : c
      )
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
    setEditingSectionId(null);
  };

  const manualSync = async () => {
    setIsSyncing(true);
    try {
      await waitForFirebase();
      await saveProjectsToFirebase(projects);
      const firebaseProjects = await loadProjectsFromFirebase();
      if (firebaseProjects.length > 0) {
        setProjects(firebaseProjects);
      }
      
      await syncMediaLibrary();
      
      alert('åŒæ­¥æˆåŠŸ!âœ“');
    } catch (error) {
      console.error('åŒæ­¥å¤±æ•—:', error);
      alert('åŒæ­¥å¤±æ•—:' + error.message);
    }
    setIsSyncing(false);
  };

  const addChapter = () => {
    if (!newChapterName.trim() || !currentProject) return;
    const updatedProject = {
      ...currentProject,
      chapters: [...currentProject.chapters, { id: Date.now(), name: newChapterName, sections: [] }]
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
    setNewChapterName('');
  };

  const deleteChapter = (chapterId) => {
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.filter(c => c.id !== chapterId)
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
  };

  const moveChapter = (index, direction) => {
    const chapters = [...currentProject.chapters];
    const newIndex = direction === 'up' ? index - 1 : index + 1;
    if (newIndex < 0 || newIndex >= chapters.length) return;
    [chapters[index], chapters[newIndex]] = [chapters[newIndex], chapters[index]];
    setProjects(projects.map(p => p.id === currentProjectId ? { ...currentProject, chapters } : p));
  };

  const addSection = (chapterId) => {
    if (!newSectionName.trim() || !currentProject) return;
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.map(c =>
        c.id === chapterId
          ? { ...c, sections: [...c.sections, { id: Date.now(), name: newSectionName, cue: '', audioFile: null, audioData: null, mediaId: null }] }
          : c
      )
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
    setNewSectionName('');
    setNewChapterId(null);
  };

  const deleteSection = (chapterId, sectionId) => {
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.map(c =>
        c.id === chapterId ? { ...c, sections: c.sections.filter(s => s.id !== sectionId) } : c
      )
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
  };

  const moveSection = (chapterId, index, direction) => {
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.map(c => {
        if (c.id === chapterId) {
          const sections = [...c.sections];
          const newIndex = direction === 'up' ? index - 1 : index + 1;
          if (newIndex < 0 || newIndex >= sections.length) return c;
          [sections[index], sections[newIndex]] = [sections[newIndex], sections[index]];
          return { ...c, sections };
        }
        return c;
      })
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
  };

  const updateSectionCue = (chapterId, sectionId, cue) => {
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.map(c =>
        c.id === chapterId
          ? { ...c, sections: c.sections.map(s => s.id === sectionId ? { ...s, cue } : s) }
          : c
      )
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
  };

  const handleAudioUpload = (chapterId, sectionId, file) => {
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (e) => {
      const dataUrl = e.target.result;
      const updatedProject = {
        ...currentProject,
        chapters: currentProject.chapters.map(c =>
          c.id === chapterId
            ? { ...c, sections: c.sections.map(s => s.id === sectionId ? { ...s, audioFile: file.name, audioData: dataUrl, mediaId: null } : s) }
            : c
        )
      };
      setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
    };
    reader.readAsDataURL(file);
  };

  const handleDeleteAudio = (chapterId, sectionId) => {
    if (window.confirm('ç¢ºå®šè¦åˆªé™¤æ­¤éŸ³æª”å—?')) {
      const updatedProject = {
        ...currentProject,
        chapters: currentProject.chapters.map(c =>
          c.id === chapterId
            ? { ...c, sections: c.sections.map(s => s.id === sectionId ? { ...s, audioFile: null, audioData: null, mediaId: null } : s) }
            : c
        )
      };
      setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
    }
  };

  const addMediaToLibrary = async (file) => {
    if (!file) return;
    
    const mediaId = Date.now();
    setUploadProgress({ [mediaId]: 0 });
    
    const reader = new FileReader();
    reader.onload = async (e) => {
      const dataUrl = e.target.result;
      const newMedia = {
        id: mediaId,
        name: file.name,
        audioData: dataUrl,
        uploadDate: new Date().toISOString(),
        storageUrl: null,
        storagePath: null
      };
      
      const updatedMedia = [...mediaLibrary, newMedia];
      setMediaLibrary(updatedMedia);
      await saveMediaToDB(updatedMedia);
      
      try {
        const storagePath = `media/${mediaId}_${file.name}`;
        const storageUrl = await uploadMediaToStorage(mediaId, newMedia, (progress) => {
          setUploadProgress(prev => ({ ...prev, [mediaId]: progress }));
        });
        
        newMedia.storageUrl = storageUrl;
        newMedia.storagePath = storagePath;
        
        const finalMedia = updatedMedia.map(m => m.id === mediaId ? newMedia : m);
        setMediaLibrary(finalMedia);
        await saveMediaToDB(finalMedia);
        await saveMediaMetadataToFirestore(newMedia);
        
        setUploadProgress(prev => {
          const newProgress = { ...prev };
          delete newProgress[mediaId];
          return newProgress;
        });
      } catch (error) {
        console.error('ä¸Šå‚³åˆ°é›²ç«¯å¤±æ•—:', error);
        setUploadProgress(prev => {
          const newProgress = { ...prev };
          delete newProgress[mediaId];
          return newProgress;
        });
      }
    };
    reader.readAsDataURL(file);
  };

  const deleteMediaFromLibrary = async (mediaId) => {
    const media = mediaLibrary.find(m => m.id === mediaId);
    if (window.confirm(`ç¢ºå®šè¦åˆªé™¤æ­¤éŸ³æª”å—?\n${media.name}\nä½¿ç”¨æ­¤éŸ³æª”çš„æ®µè½å°‡æœƒå¤±å»é€£çµã€‚`)) {
      setMediaLibrary(mediaLibrary.filter(m => m.id !== mediaId));
      
      if (media.storagePath) {
        await deleteMediaFromStorage(media.storagePath);
      }
      await deleteMediaMetadataFromFirestore(mediaId);
      
      const updatedProjects = projects.map(project => ({
        ...project,
        chapters: project.chapters.map(chapter => ({
          ...chapter,
          sections: chapter.sections.map(section => 
            section.mediaId === mediaId 
              ? { ...section, mediaId: null, audioFile: null, audioData: null }
              : section
          )
        }))
      }));
      setProjects(updatedProjects);
    }
  };

  const selectMediaForSection = (chapterId, sectionId, media) => {
    const updatedProject = {
      ...currentProject,
      chapters: currentProject.chapters.map(c =>
        c.id === chapterId
          ? { 
              ...c, 
              sections: c.sections.map(s => 
                s.id === sectionId 
                  ? { ...s, audioFile: media.name, audioData: media.audioData, mediaId: media.id } 
                  : s
              ) 
            }
          : c
      )
    };
    setProjects(projects.map(p => p.id === currentProjectId ? updatedProject : p));
    setShowMediaSelector(false);
    setSelectingForSection(null);
  };

  const getSectionAudioData = (section) => {
    if (section.mediaId) {
      const media = mediaLibrary.find(m => m.id === section.mediaId);
      return media ? media.audioData : section.audioData;
    }
    return section.audioData;
  };

  const togglePlaySection = (section, sectionId) => {
    const audioData = getSectionAudioData(section);
    if (!audioData) return;
    
    if (currentPlayingId === sectionId && audioRef.current && !audioRef.current.paused) {
      audioRef.current.pause();
      setIsPaused(true);
      return;
    }
    
    if (currentPlayingId === sectionId && isPaused && audioRef.current) {
      audioRef.current.play();
      setIsPaused(false);
      return;
    }
    
    if (audioRef.current) {
      audioRef.current.src = audioData;
      audioRef.current.load();
      audioRef.current.play();
      setCurrentPlayingId(sectionId);
      setIsPaused(false);
    }
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 flex items-center justify-center">
        <div className="text-center">
          <div className="animate-spin w-12 h-12 border-4 border-blue-200 border-t-blue-600 rounded-full mx-auto mb-4"></div>
          <p className="text-slate-600">è¼‰å…¥ä¸­...</p>
        </div>
      </div>
    );
  }

  if (currentPage === 'media') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-4 md:p-6">
        <div className="max-w-4xl mx-auto">
          <div className="flex items-center justify-between mb-6">
            <button onClick={() => setCurrentPage('projects')} className="text-blue-600 hover:text-blue-700 font-semibold text-sm md:text-base">â† å›åˆ°å°ˆæ¡ˆåˆ—è¡¨</button>
            <button
              onClick={syncMediaLibrary}
              disabled={!!syncStatus}
              className="flex items-center gap-1 px-3 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition text-xs disabled:opacity-50"
            >
              <svg className={`w-4 h-4 ${syncStatus ? 'animate-spin' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
              </svg>
              {syncStatus || 'é›²ç«¯åŒæ­¥'}
            </button>
          </div>
          
          <h1 className="text-2xl md:text-3xl font-bold text-slate-800 mb-2">ğŸµ åª’é«”è³‡æ–™åº«</h1>
          <p className="text-sm text-slate-600 mb-6">éŸ³æª”è‡ªå‹•å‚™ä»½åˆ° Firebase Storage é›²ç«¯</p>

          <div className="bg-white rounded-lg shadow-sm p-4 md:p-6 mb-6">
            <label className="flex flex-col items-center justify-center border-2 border-dashed border-slate-300 rounded-lg p-8 cursor-pointer hover:border-blue-500 hover:bg-blue-50 transition">
              <input
                type="file"
                accept="audio/mpeg,audio/mp3,audio/mp4,audio/m4a,.mp3,.mp4,.m4a"
                onChange={(e) => {
                  if (e.target.files?.[0]) {
                    addMediaToLibrary(e.target.files[0]);
                    e.target.value = '';
                  }
                }}
                className="hidden"
              />
              <svg className="w-12 h-12 text-slate-400 mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
              </svg>
              <p className="text-slate-600 font-medium">é»æ“Šä¸Šå‚³éŸ³æª”</p>
              <p className="text-xs text-slate-500 mt-1">æ”¯æ´ MP3, MP4, M4A æ ¼å¼ Â· è‡ªå‹•é›²ç«¯å‚™ä»½</p>
            </label>
          </div>

          {Object.keys(uploadProgress).length > 0 && (
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
              <p className="text-sm font-medium text-blue-800 mb-2">ä¸Šå‚³ä¸­...</p>
              {Object.entries(uploadProgress).map(([id, progress]) => (
                <div key={id} className="mb-2">
                  <div className="flex justify-between text-xs text-blue-700 mb-1">
                    <span>ä¸Šå‚³é€²åº¦</span>
                    <span>{Math.round(progress)}%</span>
                  </div>
                  <div className="w-full bg-blue-200 rounded-full h-2">
                    <div 
                      className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                      style={{ width: `${progress}%` }}
                    ></div>
                  </div>
                </div>
              ))}
            </div>
          )}

          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            {mediaLibrary.map(media => (
              <div key={media.id} className="bg-white rounded-lg shadow-sm p-4 hover:shadow-md transition">
                <div className="flex items-start gap-3">
                  <div className="flex-shrink-0 w-12 h-12 bg-blue-100 rounded-lg flex items-center justify-center">
                    <svg className="w-6 h-6 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                    </svg>
                  </div>
                  <div className="flex-1 min-w-0">
                    <p className="font-medium text-slate-800 truncate">{media.name}</p>
                    <p className="text-xs text-slate-500">{new Date(media.uploadDate).toLocaleDateString('zh-TW')}</p>
                    {media.storageUrl ? (
                      <p className="text-xs text-green-600 mt-1">â˜ï¸ å·²å‚™ä»½åˆ°é›²ç«¯</p>
                    ) : (
                      <p className="text-xs text-orange-600 mt-1">ğŸ“± åƒ…æœ¬åœ°</p>
                    )}
                  </div>
                  <button
                    onClick={() => deleteMediaFromLibrary(media.id)}
                    className="flex-shrink-0 p-2 text-red-600 hover:bg-red-50 rounded-lg transition"
                    title="åˆªé™¤"
                  >
                    <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                      <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                    </svg>
                  </button>
                </div>
              </div>
            ))}
          </div>

          {mediaLibrary.length === 0 && (
            <div className="text-center text-slate-400 py-12 bg-white rounded-lg shadow-sm">
              <p>åª’é«”åº«æ˜¯ç©ºçš„,ä¸Šå‚³ä¸€äº›éŸ³æª”å§!</p>
            </div>
          )}
        </div>
      </div>
    );
  }

  if (currentPage === 'projects') {
    return (
      <div className="min-h-screen bg-gradient-to-br from-slate-50 to-slate-100 p-4 md:p-6">
        <div className="max-w-2xl mx-auto">
          <div className="flex items-center justify-between mb-6 md:mb-8">
            <div>
              <h1 className="text-2xl md:text-4xl font-bold text-slate-800">å‚»ç“œåŠ‡åœ˜éŸ³æ•ˆç®¡ç†ç³»çµ±</h1>
              <div className="text-xs text-slate-500 flex flex-col sm:flex-row items-start sm:items-center gap-1 sm:gap-2 mt-1">
                <span>ğŸ”¥ éŸ³æª”å­˜æœ¬åœ°</span>
                <span>â˜ï¸ é›²ç«¯è‡ªå‹•å‚™ä»½</span>
              </div>
            </div>
            <div className="flex gap-2">
              <button
                onClick={() => setCurrentPage('media')}
                className="flex flex-col items-center justify-center px-3 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition"
                title="åª’é«”è³‡æ–™åº«"
              >
                <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3" />
                </svg>
                <span className="text-[10px] mt-1">åª’é«”åº«</span>
              </button>
              <button
                onClick={manualSync}
                disabled={isSyncing}
                className="flex flex-col items-center justify-center px-3 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition disabled:opacity-50 disabled:cursor-not-allowed"
              >
                <svg className={`w-5 h-5 ${isSyncing ? 'animate-spin' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                </svg>
                <span className="text-[10px] mt-1">{isSyncing ? 'åŒæ­¥ä¸­...' : 'æ‰‹å‹•åŒæ­¥'}</span>
              </button>
            </div>
          </div>
          
          <div className="bg-white rounded-lg shadow-sm p-4 md:p-6 mb-6">
            <div className="flex flex-col sm:flex-row gap-2">
              <input
                type="text"
                value={newProjectName}
                onChange={(e) => setNewProjectName(e.target.value)}
                placeholder="è¼¸å…¥æ–°å°ˆæ¡ˆåç¨±..."
                className="flex-1 px-3 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm md:text-base"
                onKeyPress={(e) => e.key === 'Enter' && addProject()}
              />
              <button onClick={addProject} className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition text-sm md:text-base whitespace-nowrap">
                â• æ–°å¢
              </button>
            </div>
          </div>

          <div className="space-y-3">
            {projects.map((p, idx) => (
              <div key={p.id} className="bg-white rounded-lg shadow-sm p-4 hover:shadow-md transition">
                {editingProjectId === p.id ? (
                  <div className="flex gap-2 flex-1">
                    <input
                      type="text"
                      value={editingProjectName}
                      onChange={(e) => setEditingProjectName(e.target.value)}
                      className="flex-1 px-3 py-2 border border-blue-400 rounded focus:outline-none focus:ring-2 focus:ring-blue-500 text-sm"
                      autoFocus
                      onKeyPress={(e) => e.key === 'Enter' && updateProjectName(p.id, editingProjectName)}
                    />
                    <button onClick={() => updateProjectName(p.id, editingProjectName)} className="px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 text-sm">âœ“</button>
                    <button onClick={() => setEditingProjectId(null)} className="px-3 py-2 bg-slate-300 text-slate-700 rounded hover:bg-slate-400 text-sm">âœ•</button>
                  </div>
                ) : (
                  <>
                    <div className="flex-1 mb-3">
                      <h3 
                        className="font-semibold text-slate-800 text-base md:text-lg hover:text-blue-600 hover:underline cursor-pointer"
                        onClick={() => {
                          setEditingProjectId(p.id);
                          setEditingProjectName(p.name);
                        }}
                      >{p.name}</h3>
                      <p className="text-xs md:text-sm text-slate-500">{p.chapters.length} å¹•</p>
                    </div>
                    <div className="grid grid-cols-3 sm:flex sm:flex-wrap gap-2">
                      <button 
                        onClick={() => { setCurrentProjectId(p.id); setCurrentPage('play'); }} 
                        className="flex flex-col items-center justify-center p-2 text-green-600 hover:bg-green-50 rounded-lg transition"
                      >
                        <svg className="w-4 h-4 md:w-5 md:h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z" />
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        <span className="text-[10px] md:text-xs">é€²å…¥å°ˆæ¡ˆ</span>
                      </button>
                      <button 
                        onClick={() => { setCurrentProjectId(p.id); setCurrentPage('settings'); }} 
                        className="flex flex-col items-center justify-center p-2 text-slate-600 hover:bg-slate-100 rounded-lg transition"
                      >
                        <svg className="w-4 h-4 md:w-5 md:h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                        </svg>
                        <span className="text-[10px] md:text-xs">ç·¨è¼¯å°ˆæ¡ˆ</span>
                      </button>
                      <button 
                        onClick={() => moveProject(idx, 'up')} 
                        disabled={idx === 0} 
                        className="flex flex-col items-center justify-center p-2 text-slate-600 hover:bg-slate-100 disabled:opacity-30 disabled:cursor-not-allowed rounded-lg transition"
                      >
                        <svg className="w-4 h-4 md:w-5 md:h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M5 15l7-7 7 7" />
                        </svg>
                        <span className="text-[10px] md:text-xs">ä¸Šç§»</span>
                      </button>
                      <button 
                        onClick={() => moveProject(idx, 'down')} 
                        disabled={idx === projects.length - 1} 
                        className="flex flex-col items-center justify-center p-2 text-slate-600 hover:bg-slate-100 disabled:opacity-30 disabled:cursor-not-allowed rounded-lg transition"
                      >
                        <svg className="w-4 h-4 md:w-5 md:h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M19 9l-7 7-7-7" />
                        </svg>
                        <span className="text-[10px] md:text-xs">ä¸‹ç§»</span>
                      </button>
                      <button 
                        onClick={() => duplicateProject(p)} 
                        className="flex flex-col items-center justify-center p-2 text-blue-600 hover:bg-blue-50 rounded-lg transition"
                      >
                        <svg className="w-4 h-4 md:w-5 md:h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                        </svg>
                        <span className="text-[10px] md:text-xs">è¤‡è£½</span>
                      </button>
                      <button 
                        onClick={() => deleteProject(p.id)} 
                        className="flex flex-col items-center justify-center p-2 text-red-600 hover:bg-red-50 rounded-lg transition"
                      >
                        <svg className="w-4 h-4 md:w-5 md:h-5 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={1.5} d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
                        </svg>
                        <span className="text-[10px] md:text-xs">åˆªé™¤</span>
                      </button>
                    </div>
                  </>
                )}
              </div>
            ))}
          </div>

          {projects.length === 0 && (
            <div className="text-center text-slate-400 py-12">
              <p>é‚„æ²’æœ‰ä»»ä½•å°ˆæ¡ˆ,æ–°å¢ä¸€å€‹é–‹å§‹å§!</p>
            </div>
          )}
        </div>
      </div>
    );
  }

  return <div>è«‹é¸æ“‡å°ˆæ¡ˆ</div>;
}

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TheaterApp />);
</script>
</body>
</html>